from love use love
use gfx
from gfx use (stableRandomColor as rcol)
use input
use sfx

// TODO:
//  - Some particles when you flip, maybe even screen shake?
//  - A menu or intro screen?
//  - Fix the sounds
//  - Add some music
//  - Add in an AI?

Piece :: enum
    Black,
    White,
    Empty,
end

other_color :: fn piece ->
    case piece do
        Black -> Piece.Black end
        White -> Piece.White end
        Empty -> <!> end
    end
end

grid_size :: 31.
dirs :: [(1, 0), (0, 1), (1, 1), (-1, 0), (0, -1), (-1, -1), (-1, 1), (1, -1)]

valid_coord :: fn coord ->
    (0 <= coord[0] and coord[0] < 8 and
     0 <= coord[1] and coord[1] < 8)
end

any :: fn l: [*A], pred: fn *A -> bool -> bool
    result := false
    l -> for_each' fn x ->
        result = result or pred' x
    end
    result
end

board_at :: fn board, coord ->
    board[coord[1]][coord[0]]
end

board_place :: fn board, coord, piece ->
    board[coord[1]][coord[0]] = piece
end

valid_placement :: fn board, coord ->
    (valid_coord(coord)
     and board_at(board, coord) == Piece.Empty
     and any' dirs, fn delta ->
        p :: coord + delta
        valid_coord(p) and board_at(board, p) != Piece.Empty
    end
   )
end

board_is_full :: fn board ->
    x := 0
    loop x < 8 do
        y := 0
        loop y < 8 do
            if board_at(board, (x, y)) == Piece.Empty do ret false end
            y += 1
        end
        x += 1
    end
    ret true
end

count_pieces :: fn board ->
    blacks := 0
    whites := 0
    x := 0
    loop x < 8 do
        y := 0
        loop y < 8 do
            piece :: board_at(board, (x, y))
            if piece == Piece.White do
                whites += 1
            else do if piece == Piece.Black do
                    blacks += 1
                end
            end
            y += 1
        end
        x += 1
    end
    (blacks, whites)
end

screen_to_board :: fn offset, size, mouseCoords ->
    shifted :: (mouseCoords - offset) * (1 / size[0], 1 / size[1])
    (floor(shifted[0]), floor(shifted[1]))
end

board_to_screen :: fn offset, size, coord ->
    offset + size * (as_float(coord[0]), as_float(coord[1]))
end

flip_if_matches :: fn board, coord, piece, dir ->
    if (not valid_coord(coord))
    or board_at(board, coord) == Piece.Empty do ret false end

    if board_at(board, coord) == other_color(piece)
    or flip_if_matches(board, coord + dir, piece, dir) do
        board_place(board, coord, piece)
        true
    else
        false
    end
end

place_piece :: fn board, coord, piece ->
    success :: case board_at(board, coord) do
        Empty ->
            board_place(board, coord, piece)
            true
        end
        White -> false end
        Black -> false end
    end
    if not success do ret success end

    dirs -> for_each' fn dir do
        flip_if_matches' board, coord + dir, piece, dir
    end

    audio : sfx.Sound : list.random_choice(place_sfx)
    audio.playp' (0.4, 0.1), (0.9, 1.1)

    success
end

Maybe :: enum
    Just *
    Nothing
end

State :: blob {
    board: [[Piece]],
    turn: int,
    coord: Maybe, // (Int, Int)
}

place_sfx := []

start :: fn do

    place_sfx = [
        sfx.newSound("res/place001.wav", false, sfx.SoundType.Static),
        sfx.newSound("res/place002.wav", false, sfx.SoundType.Static),
        sfx.newSound("res/place003.wav", false, sfx.SoundType.Static),
        sfx.newSound("res/place004.wav", false, sfx.SoundType.Static),
        sfx.newSound("res/place005.wav", false, sfx.SoundType.Static),
    ]

    bigFont :: gfx.newFont("res/LibreBaskerville-Italic.ttf", 100)
    smallFont :: gfx.newFont("res/LibreBaskerville-Italic.ttf", 30)
    board_img :: gfx.newImage' "res/board.png"
    black_img :: gfx.newImage' "res/black.png"
    white_img :: gfx.newImage' "res/white.png"

    draw_board :: fn pos, scale, state do
        top_left_offset :: pos + (7., 7.) * scale
        size :: (grid_size, grid_size) * scale
        board_img.draw' pos, 0.0, scale
        x := 0
        loop x < 8 do
            y := 0
            loop y < 8 do
                offset :: board_to_screen' top_left_offset, size, (x, y)
                case board_at' state.board, (x, y) do
                    Black -> black_img.draw(offset, 0.0, scale) end
                    White -> white_img.draw(offset, 0.0, scale) end
                    Empty -> end
                end

                y += 1
            end
            x += 1
        end

        active :: screen_to_board' top_left_offset, size, input.mousePos()
        case state.coord do
            Just coord ->
                offset :: board_to_screen' top_left_offset, size, active
                gfx.drawCircle( gfx.rgba(0., 0., 0., 0.2)
                              , offset + size * (0.5, 0.5) - (2., 2.) * scale
                              , (size[0] - 5.0) / 4)
            end
            else do end
        end
    end

    pressed := false
    update_board :: fn pos, scale, state ->
        top_left_offset :: pos + (13., 13.)
        size :: (grid_size, grid_size) * scale

        active :: screen_to_board' top_left_offset, size, input.mousePos()
        coord :: if valid_placement' state.board, active do
            if state.turn == 0
            and pressed
            and place_piece' state.board, active, Piece.White do
                state.turn = 1
            else if state.turn == 1
                 and pressed
                 and place_piece' state.board, active, Piece.Black do
                state.turn = 0
            end
            Maybe.Just active
        else
            Maybe.Nothing
        end

        State { board: state.board, coord: coord, turn: state.turn }
    end

    scale :: (2., 2.)
    pos :: (gfx.screenSizef() - board_img.getSize() * scale) * (0.5, 0.5)

    state := State { board: [], coord: Maybe.Nothing, turn: 0 }

    y := 0
    loop y < 8 do
        state.board -> list.push' [Piece.Empty, Piece.Empty, Piece.Empty, Piece.Empty
                            ,Piece.Empty, Piece.Empty, Piece.Empty, Piece.Empty]
        y += 1
    end

    board_place' state.board, (3, 3), Piece.Black
    board_place' state.board, (4, 3), Piece.White
    board_place' state.board, (3, 4), Piece.White
    board_place' state.board, (4, 4), Piece.Black

    love.update = fn delta do
        state = update_board' pos, scale, state
        pressed = false
    end

    love.draw = fn do
        draw_board' pos, scale, state
        if board_is_full' state.board do
            text_pos :: (100.0, 100.0)

            gfx.drawRect' gfx.rgba(0., 0., 0., 0.1), (0., 0.), gfx.screenSizef'
            bigFont.drawText' gfx.rgb(1., 1., 1.), "Othello", text_pos
            num_pieces :: count_pieces' state.board
            message :: if num_pieces[0] == num_pieces[1] do
                "Tie!"
            else do if num_pieces[0] > num_pieces[1] do
                    "Black wins!"
                else do
                    "White wins!"
                end
            end
            smallFont.drawText' gfx.rgb(1., 1., 1.), message, text_pos + (10.0, 110.0)
        end
    end

    love.keypressed = fn key, scancode, repeat do
    end

    love.keyreleased = fn key, scancode do
    end

    love.mousepressed = fn x, y, button, istouch, presses do
        pressed = button == 1
    end
end
